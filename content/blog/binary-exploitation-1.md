+++
title = "Beginners notes on binary exploitation"
date = 2025-05-11
taxonomies.categories = ["binary exploitation"]
draft = true
+++

This is really notes for myself but it helps writing stuff out!

My main resources for learning more about assembly, the CPU (Computer architecture in general really) are:  
- [Hacking- The Art of Exploitation, 2nd edition](https://www.amazon.com/Hacking-Art-Exploitation-Jon-Erickson/dp/1593271441)
- [LiveOverflow on YouTube](https://youtube.com/playlist?list=PLhixgUqwRTjxglIswKp9mpkfPNfHkzyeN) Big thanks to LiveOverflow for his amazing work! üôèüèº

## Let's write a C program

The code below was originally made by [LiveOverflow](https://www.youtube.com/LiveOverflow).  
It's a simple program that compares user input to the string stored in the program.  
I want to run this program and see what happens under the hood to learn how we can exploit this.

``` C
// license-check.c
#include <string.h>
#include <stdio.h>

int main(int argc, char * argv[]) {
    if (argc == 2) {
        printf("Checking License: %s\n", argv[1]);
        if (strcmp(argv[1], "AAAA-Z10N-42-OK") == 0) {
            printf("Access Granted!\n");
        } else {
            printf("WRONG!\n");
        }
    } else {
        printf("Usage: <key>\n");
    }
    return 0;
}
```

Let's compile this code into a binary using the GNU compiler collection (gcc). Then lets run it

```bash
$ gcc license-check.c license-check
$ chmod +x license-check
$ ./license-check MY-KEY-ATTEMPT
$ Checking License:
$ WRONG!
```

How very interesting. Let's take a closer look with the Gnu Debugger "gdb"

## Debugging using GDB
We can load our program into gdb by executing gdb with the file and then disassemble the main function.

```bash 
$ gdb license_1
Dump of assembler code for function main:
   0x0000000000001159 <+0>:     push   %rbp
   0x000000000000115a <+1>:     mov    %rsp,%rbp
   0x000000000000115d <+4>:     sub    $0x10,%rsp
   0x0000000000001161 <+8>:     mov    %edi,-0x4(%rbp)
   0x0000000000001164 <+11>:    mov    %rsi,-0x10(%rbp)
   0x0000000000001168 <+15>:    cmpl   $0x2,-0x4(%rbp)
   0x000000000000116c <+19>:    jne    0x11d3 <main+122>
   0x000000000000116e <+21>:    mov    -0x10(%rbp),%rax
   0x0000000000001172 <+25>:    add    $0x8,%rax
   0x0000000000001176 <+29>:    mov    (%rax),%rax
   0x0000000000001179 <+32>:    mov    %rax,%rsi
   0x000000000000117c <+35>:    lea    0xe81(%rip),%rax        # 0x2004
   0x0000000000001183 <+42>:    mov    %rax,%rdi
   0x0000000000001186 <+45>:    mov    $0x0,%eax
   0x000000000000118b <+50>:    call   0x1040 <printf@plt>
   0x0000000000001190 <+55>:    mov    -0x10(%rbp),%rax
   0x0000000000001194 <+59>:    add    $0x8,%rax
   0x0000000000001198 <+63>:    mov    (%rax),%rax
   0x000000000000119b <+66>:    lea    0xe78(%rip),%rdx        # 0x201a
   0x00000000000011a2 <+73>:    mov    %rdx,%rsi
   0x00000000000011a5 <+76>:    mov    %rax,%rdi
   0x00000000000011a8 <+79>:    call   0x1050 <strcmp@plt>
   0x00000000000011ad <+84>:    test   %eax,%eax
   0x00000000000011af <+86>:    jne    0x11c2 <main+105>
   0x00000000000011b1 <+88>:    lea    0xe72(%rip),%rax        # 0x202a
   0x00000000000011b8 <+95>:    mov    %rax,%rdi
   0x00000000000011bb <+98>:    call   0x1030 <puts@plt>
   0x00000000000011c0 <+103>:   jmp    0x11e2 <main+137>
   0x00000000000011c2 <+105>:   lea    0xe71(%rip),%rax        # 0x203a
   0x00000000000011c9 <+112>:   mov    %rax,%rdi
   0x00000000000011cc <+115>:   call   0x1030 <puts@plt>
   0x00000000000011d1 <+120>:   jmp    0x11e2 <main+137>
   0x00000000000011d3 <+122>:   lea    0xe67(%rip),%rax        # 0x2041
   0x00000000000011da <+129>:   mov    %rax,%rdi
   0x00000000000011dd <+132>:   call   0x1030 <puts@plt>
   0x00000000000011e2 <+137>:   mov    $0x0,%eax
   0x00000000000011e7 <+142>:   leave  
   0x00000000000011e8 <+143>:   ret    
End of assembler dump.
```

The output includes a lot of `%` characters which looks awful. This is AT-T syntax! We can change that into intel syntax by issuing the following command in gdb. After doing so, lets disassemble again.

``` bash
set disassembly-flavor intel
(gdb) disassemble main
Dump of assembler code for function main:
   0x0000000000001159 <+0>:     push   rbp
   0x000000000000115a <+1>:     mov    rbp,rsp
   0x000000000000115d <+4>:     sub    rsp,0x10
   0x0000000000001161 <+8>:     mov    DWORD PTR [rbp-0x4],edi
   0x0000000000001164 <+11>:    mov    QWORD PTR [rbp-0x10],rsi
   0x0000000000001168 <+15>:    cmp    DWORD PTR [rbp-0x4],0x2
   0x000000000000116c <+19>:    jne    0x11d3 <main+122>
   0x000000000000116e <+21>:    mov    rax,QWORD PTR [rbp-0x10]
   0x0000000000001172 <+25>:    add    rax,0x8
   0x0000000000001176 <+29>:    mov    rax,QWORD PTR [rax]
   0x0000000000001179 <+32>:    mov    rsi,rax
   0x000000000000117c <+35>:    lea    rax,[rip+0xe81]        # 0x2004
   0x0000000000001183 <+42>:    mov    rdi,rax
   0x0000000000001186 <+45>:    mov    eax,0x0
   0x000000000000118b <+50>:    call   0x1040 <printf@plt>
   0x0000000000001190 <+55>:    mov    rax,QWORD PTR [rbp-0x10]
   0x0000000000001194 <+59>:    add    rax,0x8
   0x0000000000001198 <+63>:    mov    rax,QWORD PTR [rax]
   0x000000000000119b <+66>:    lea    rdx,[rip+0xe78]        # 0x201a
   0x00000000000011a2 <+73>:    mov    rsi,rdx
   0x00000000000011a5 <+76>:    mov    rdi,rax
   0x00000000000011a8 <+79>:    call   0x1050 <strcmp@plt>
   0x00000000000011ad <+84>:    test   eax,eax
   0x00000000000011af <+86>:    jne    0x11c2 <main+105>
   0x00000000000011b1 <+88>:    lea    rax,[rip+0xe72]        # 0x202a
   0x00000000000011b8 <+95>:    mov    rdi,rax
   0x00000000000011bb <+98>:    call   0x1030 <puts@plt>
   0x00000000000011c0 <+103>:   jmp    0x11e2 <main+137>
   0x00000000000011c2 <+105>:   lea    rax,[rip+0xe71]        # 0x203a
   0x00000000000011c9 <+112>:   mov    rdi,rax
   0x00000000000011cc <+115>:   call   0x1030 <puts@plt>
   0x00000000000011d1 <+120>:   jmp    0x11e2 <main+137>
   0x00000000000011d3 <+122>:   lea    rax,[rip+0xe67]        # 0x2041
   0x00000000000011da <+129>:   mov    rdi,rax
   0x00000000000011dd <+132>:   call   0x1030 <puts@plt>
   0x00000000000011e2 <+137>:   mov    eax,0x0
   0x00000000000011e7 <+142>:   leave  
   0x00000000000011e8 <+143>:   ret    
End of assembler dump.
```
Now that's better and completely understandable right üòÖ ?  
We can set a breakpoint at the main function, run the program and check the registers.

```bash
(gdb) break *main
Note: breakpoint 1 also set at pc 0x555555555159.
Breakpoint 2 at 0x555555555159
(gdb) run MY-SECRET-KEY
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /home/kali/binary_exploitation/license/license_1 MY-SECRET-KEY
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".

Breakpoint 1, 0x0000555555555159 in main ()
(gdb) info registers
rax            0x555555555159      93824992235865
rbx            0x0                 0
rcx            0x555555557df0      93824992247280
rdx            0x7fffffffdf90      140737488347024
rsi            0x7fffffffdf78      140737488347000
rdi            0x2                 2
rbp            0x2                 0x2
rsp            0x7fffffffde68      0x7fffffffde68
r8             0x7ffff7f9fef0      140737353744112
r9             0x7ffff7fcd8e0      140737353930976
r10            0x7ffff7fc8878      140737353910392
r11            0x7ffff7fe0450      140737354007632
r12            0x7fffffffdf78      140737488347000
r13            0x555555555159      93824992235865
r14            0x555555557df0      93824992247280
r15            0x7ffff7ffd020      140737354125344
rip            0x555555555159      0x555555555159 <main>
eflags         0x246               [ PF ZF IF ]
cs             0x33                51
ss             0x2b                43
ds             0x0                 0
es             0x0                 0
fs             0x0                 0
gs             0x0                 0
(gdb) 
```

In here, we can se that the `rip` register points to an address in main. 
We can now step through instructions with the "Next instruction (ni)" and "Step instruction (si)" command and continually check the registers. `si` will step through function calls and at the moment we are not interested in this, so we will use `ni`.  
Also, we can just press `ENTER` to avoid retyping the last command!

```bash
(gdb) si
0x000055555555515a in main ()
(gdb) info registers
rax            0x555555555159      93824992235865
rbx            0x0                 0
rcx            0x555555557df0      93824992247280
rdx            0x7fffffffdf90      140737488347024
rsi            0x7fffffffdf78      140737488347000
rdi            0x2                 2
rbp            0x2                 0x2
rsp            0x7fffffffde60      0x7fffffffde60
r8             0x7ffff7f9fef0      140737353744112
r9             0x7ffff7fcd8e0      140737353930976
r10            0x7ffff7fc8878      140737353910392
r11            0x7ffff7fe0450      140737354007632
r12            0x7fffffffdf78      140737488347000
r13            0x555555555159      93824992235865
r14            0x555555557df0      93824992247280
r15            0x7ffff7ffd020      140737354125344
rip            0x55555555515a      0x55555555515a <main+1>
eflags         0x246               [ PF ZF IF ]
cs             0x33                51
ss             0x2b                43
ds             0x0                 0
es             0x0                 0
fs             0x0                 0
gs             0x0                 0
(gdb) 
```

`rip` now points to a new address!

Let's step through and see if we jump from the "jne" instruction.

```bash
(gdb) disassemble main
Dump of assembler code for function main:
   0x0000555555555159 <+0>:     push   rbp
   0x000055555555515a <+1>:     mov    rbp,rsp
=> 0x000055555555515d <+4>:     sub    rsp,0x10
   0x0000555555555161 <+8>:     mov    DWORD PTR [rbp-0x4],edi
   0x0000555555555164 <+11>:    mov    QWORD PTR [rbp-0x10],rsi
   0x0000555555555168 <+15>:    cmp    DWORD PTR [rbp-0x4],0x2
   0x000055555555516c <+19>:    jne    0x5555555551d3 <main+122>
   0x000055555555516e <+21>:    mov    rax,QWORD PTR [rbp-0x10]
   0x0000555555555172 <+25>:    add    rax,0x8
   0x0000555555555176 <+29>:    mov    rax,QWORD PTR [rax]
   0x0000555555555179 <+32>:    mov    rsi,rax
   0x000055555555517c <+35>:    lea    rax,[rip+0xe81]        # 0x555555556004
   0x0000555555555183 <+42>:    mov    rdi,rax
   0x0000555555555186 <+45>:    mov    eax,0x0
   0x000055555555518b <+50>:    call   0x555555555040 <printf@plt>
   0x0000555555555190 <+55>:    mov    rax,QWORD PTR [rbp-0x10]
   0x0000555555555194 <+59>:    add    rax,0x8
   0x0000555555555198 <+63>:    mov    rax,QWORD PTR [rax]
   0x000055555555519b <+66>:    lea    rdx,[rip+0xe78]        # 0x55555555601a
   0x00005555555551a2 <+73>:    mov    rsi,rdx
   0x00005555555551a5 <+76>:    mov    rdi,rax
   0x00005555555551a8 <+79>:    call   0x555555555050 <strcmp@plt>
   0x00005555555551ad <+84>:    test   eax,eax
   0x00005555555551af <+86>:    jne    0x5555555551c2 <main+105>
   0x00005555555551b1 <+88>:    lea    rax,[rip+0xe72]        # 0x55555555602a
   0x00005555555551b8 <+95>:    mov    rdi,rax
   0x00005555555551bb <+98>:    call   0x555555555030 <puts@plt>
   0x00005555555551c0 <+103>:   jmp    0x5555555551e2 <main+137>
   0x00005555555551c2 <+105>:   lea    rax,[rip+0xe71]        # 0x55555555603a
   0x00005555555551c9 <+112>:   mov    rdi,rax
   0x00005555555551cc <+115>:   call   0x555555555030 <puts@plt>
   0x00005555555551d1 <+120>:   jmp    0x5555555551e2 <main+137>
   0x00005555555551d3 <+122>:   lea    rax,[rip+0xe67]        # 0x555555556041
   0x00005555555551da <+129>:   mov    rdi,rax
   0x00005555555551dd <+132>:   call   0x555555555030 <puts@plt>
   0x00005555555551e2 <+137>:   mov    eax,0x0
   0x00005555555551e7 <+142>:   leave  
   0x00005555555551e8 <+143>:   ret    
End of assembler dump.
(gdb) si
0x0000555555555161 in main ()
(gdb) ni
0x0000555555555164 in main ()
(gdb) 
0x0000555555555168 in main ()
(gdb) 
0x000055555555516c in main () //Here is our "Jump if not equal" instruction
(gdb) 
0x00005555555551d3 in main () // It jumped to the address referenced in the "jne" instruction!
(gdb) 

```


## Using Radare2
Time to bring out the big guns‚ÄîRadare2 (a.k.a. r2). It‚Äôs like GDB on steroids, but with a steeper learning curve and an interface that feels like you‚Äôve hacked your way into an alien mainframe.

1. **Open the binary**

   ```bash
   r2 -A license_1
   ```

   The `-A` flag runs all the auto-analysis passes up front. You‚Äôll get a prompt that looks like this:

   ```
   [0x00001159]>
   ```

2. **List functions**

   ```
   afl
   ```

   You should see `sym.main` in the list.

3. **Disassemble main**

   ```
   pdf @ sym.main
   ```

   (‚Äúprint disassembly of function‚Äù‚ÄîRadare‚Äôs quirky shorthand.) You‚Äôll recognize essentially the same push/mov/cmp/jne sequence, but now you can scroll, search, and even graph it with `VV` (uppercase ‚Äúv‚Äù).

4. **Set a breakpoint & run**

   ```
   db sym.main
   dc MY-SECRET-KEY
   ```

   `db` drops a breakpoint, and `dc` (‚Äúcontinue‚Äù) runs the program with your argument. Check registers with

   ```
   dr
   ```

   and step one instruction at a time with

   ```
   ds
   ```

5. **Hex-patch the license string**
   Let‚Äôs be naughty and change `"WRONG!"` to `"LOL, NOPE"` in the binary itself:

   ```
   wx 4c4f4c2c204e4f5045 @ 0x203a
   ```

   (That hex is ASCII for `LOL, NOPE`.) Then save your patch:

   ```
   wq
   ```

   Now when you run without the correct key, your binary insults you directly.

---

## What Did We Learn?

**In GDB, we‚Ä¶**

- Launched the binary with our test key using `run MY-SECRET-KEY`.
- Switched from AT\&T to Intel syntax via `set disassembly-flavor intel`.
- Disassembled `main` with `disassemble main`.
- Placed a breakpoint at `main` (`break *main`) and restarted.
- Stepped through instructions one at a time with `si`/`ni`.
- Inspected CPU state at each step using `info registers`.

**In Radare2, we‚Ä¶**
- Opened and auto-analyzed the binary with r2 -A license_1.
- Listed functions using afl to find sym.main.
- Disassembled main via pdf @ sym.main.
- Set a breakpoint at sym.main with db sym.main.
- Continued execution with dc MY-SECRET-KEY.
- Stepped through instructions one at a time using ds.
- Examined registers at each point via the dr command.

Stay tuned, and remember: with great power (to patch binaries and crash servers) comes great responsibility (and maybe some sleepless nights).
